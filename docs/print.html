<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Borre 개발노트</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="tutorial.html">이 문서는?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 방법론</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="DDD.html"><strong aria-hidden="true">1.1.</strong> DDD</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ddd-aggregate.html"><strong aria-hidden="true">1.1.1.</strong> Aggregate</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 도구</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> 인텔리제이</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Gradle</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> Git</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="precommit-hook.html"><strong aria-hidden="true">2.3.1.</strong> Precommit hook</a></li><li class="chapter-item expanded "><a href="git-subrepo.html"><strong aria-hidden="true">2.3.2.</strong> (TBD) Git subrepo</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 자바</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="recursive-generic.html"><strong aria-hidden="true">3.1.</strong> Generic Recursive type bound</a></li><li class="chapter-item expanded "><a href="bounded-wildcards.html"><strong aria-hidden="true">3.2.</strong> Bounded Wildcards</a></li><li class="chapter-item expanded "><a href="raw-type.html"><strong aria-hidden="true">3.3.</strong> Raw Type</a></li><li class="chapter-item expanded "><a href="null.html"><strong aria-hidden="true">3.4.</strong> (TBD) Null</a></li><li class="chapter-item expanded "><a href="javadoc.html"><strong aria-hidden="true">3.5.</strong> Javadoc</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 라이브러리</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> 자바 라이브러리</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.1.</strong> Spring</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-di.html"><strong aria-hidden="true">4.1.1.1.</strong> Spring DI</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.2.</strong> JPA</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="jpa-transaction-io-call.html"><strong aria-hidden="true">4.1.2.1.</strong> (TBD) JPA Transaction안에서 IO 처리</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.3.</strong> Swing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.4.</strong> Spring Boot</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-boot-actuator.html"><strong aria-hidden="true">4.1.4.1.</strong> (안씀)Spring boot actuator</a></li><li class="chapter-item expanded "><a href="spring-boot-web-filter-request-log.html"><strong aria-hidden="true">4.1.4.2.</strong> Spring Boot Web Filter를 사용해서 request log 남기기</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.4.3.</strong> Spring Boot 에러 처리</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.4.4.</strong> Spring Data JPA</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-data-jpa-io-in-transaction.html"><strong aria-hidden="true">4.1.4.4.1.</strong> (TBD) Spring Data JPA Transaction중 IO</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="junit.html"><strong aria-hidden="true">4.1.5.</strong> (TBD)JUnit</a></li><li class="chapter-item expanded "><a href="jackson.html"><strong aria-hidden="true">4.1.6.</strong> (TBD)Jackson</a></li></ol></li><li class="chapter-item expanded "><a href="caver.html"><strong aria-hidden="true">4.2.</strong> (TBD) Caver</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Web3j</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> bitcoinj</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="bitcoinj-hdwallet.html"><strong aria-hidden="true">4.4.1.</strong> (TBD) bitcoinj HD wallet</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 블록체인</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hd-wallet.html"><strong aria-hidden="true">5.1.</strong> HD wallet</a></li><li class="chapter-item expanded "><a href="secp256k1.html"><strong aria-hidden="true">5.2.</strong> (TBD) secp256k1</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Klaytn</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="klaytn-fee.html"><strong aria-hidden="true">5.3.1.</strong> (TBD) klaytn fee 계산</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> 256비트 디비에 저장하기</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> crypto</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> ECDSA</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecdsa-public-key-encoding.html"><strong aria-hidden="true">6.1.1.</strong> ECDSA 공개키 인코딩</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Borre 개발노트</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="이-문서는"><a class="header" href="#이-문서는">이 문서는</a></h1>
<p>해치랩스에 입사하여 새롭게 공부한 내용들을 정리한 문서다. 외부에
공개해도 되는 내용들만을 적는다.</p>
<h1 id="ddd"><a class="header" href="#ddd">DDD</a></h1>
<p>코드의 구조를 domain에 맞추는 개발 방법론이다. 서로 다른
어플리케이션이라도 같은 도메인을 사용하면 코드를 재활용할 수 있다.</p>
<h2 id="어떻게-구현하지"><a class="header" href="#어떻게-구현하지">어떻게 구현하지</a></h2>
<p>블록체인 도메인에 대해서 domain 네임스페이스를 만들고 이 안에 관련
도메인을 구현한다. 최대한 primitive 타입 대신에 도메인 타입을 만들고
이 도메인 타입에 기능을 구현하는 함수를 넣는다.</p>
<h2 id="db와의-관계"><a class="header" href="#db와의-관계">DB와의 관계</a></h2>
<p>디비에 저장해야 하는 도메인 객체인 경우 JPA를 사용해서 한 도메인
객체가 테이블의 한 row가 되게 설계한다.</p>
<h2 id="도메인과-외부-세계"><a class="header" href="#도메인과-외부-세계">도메인과 외부 세계</a></h2>
<p>도메인은 도메인 객체 이외에 의존성을 제거한다. 만약 도메인이 외부
코드를 호출해야 한다면 도메인 내부에 필요한 기능에 대해 Interface를
구현하고 이를 밖에서 구현한다. 대표적인 예시로 Bitcoin RPC client가
있다. 도메인 코드에서 Bitcoin 노드에 데이터를 요청해 받아와야 하는
경우 필요한 Bitcoin RPC 요청을 정의한 interface를 도메인에 만들고 이를
도메인 외부에서 구현한다.</p>
<h2 id="도메인-오브젝트-만들기"><a class="header" href="#도메인-오브젝트-만들기">도메인 오브젝트 만들기</a></h2>
<h3 id="디비-엔터티"><a class="header" href="#디비-엔터티">디비 엔터티</a></h3>
<p>디비에 저장되는 도메인 오브젝트를 모델링할 때 사용한다. 도메인
오브젝트는 자신이 가진 row를 외부에 노출하지
않는다.<sup class="footnote-reference"><a href="#domain-object-get-field">1</a></sup></p>
<div class="footnote-definition" id="domain-object-get-field"><sup class="footnote-definition-label">1</sup>
<p>DTO를 만들기 위해선 어쩔 수 없이 노출해야
한다. 하지만 도메인 코드 내부에서는 접근하지 말자.</p>
</div>
<h3 id="도메인-서비스"><a class="header" href="#도메인-서비스">도메인 서비스</a></h3>
<p>데이터가 아닌 행위에 대한 도메인 개념들이 있다. 한 도메인 디비
엔터티만 관련이 있다면 그 도메인 오브젝트에 넣을 수 있겠지만, 여러
디비 엔터티가 관련되어 있으면 넣을 곳이 애매하다.</p>
<p>이를 도메인 서비스 클래스를 만들어서 해결한다. 도메인 서비스 클래스는
스테이트를 가지지 않는다. 싱글턴으로 만들며, 보통 Bean으로 만들어
사용한다.</p>
<h1 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h1>
<h2 id="domain-driven-design-책에서"><a class="header" href="#domain-driven-design-책에서">Domain-driven design 책에서</a></h2>
<p>6장 &quot;The life cycle of a domain object&quot;에 Aggregates에 대한 내용이
정리되어 있다.</p>
<p>Aggregates는 도메인 객체 사이의 소유 관계를 사용해서 도메인 모델의
복잡성을 줄이는 방법이다.</p>
<p>DDD 책의 예시를 가져오겠다, <code>자동차</code>, <code>타이어</code>, <code>바퀴 휠</code> 모델이 있다.
<code>타이어</code>와 <code>바퀴 휠</code>, <code>자동차</code> 모델은 서로 함께 수정되어야 할 때가
많다. 실수로 하나의 모델만 수정하게 되면 쉽게 버그가 만들어진다.</p>
<p>이를 단순화하는 방법으로 Aggregates를 쓸 수 있다. <code>타이어</code>나
<code>바퀴휠</code>을 수정하는 코드를 항상 <code>자동차</code>를 통해서 호출하게 만드는
것이다. <code>자동차</code>는 필요한 맥락을 전부 알고 있으므로 실수할 여지가
적다. <code>자동차</code>를 사용하는 코드도 디테일에 신경쓰지 않을 수 있어서 코드
작성이 쉬워진다.</p>
<h2 id="aggregates를-jpa에서-사용하기"><a class="header" href="#aggregates를-jpa에서-사용하기">Aggregates를 JPA에서 사용하기</a></h2>
<p>JPA의 Cascade 옵션을 사용하면 편라하게 Aggregate 구조를 사용할 수
있다. Cascade 옵션으로 루트 객체를 저장할 때 자식 객체까지 다
저장하거나, 루트를 지울 때 자식 객체까지 전부 지워지게 만들 수 있다.</p>
<h2 id="마틴-파울러가-쓴-ddd_aggregate에-관한-글"><a class="header" href="#마틴-파울러가-쓴-ddd_aggregate에-관한-글">마틴 파울러가 쓴 DDD_Aggregate에 관한 글</a></h2>
<p>링크: <a href="https://martinfowler.com/bliki/DDD_Aggregate.html">https://martinfowler.com/bliki/DDD_Aggregate.html</a></p>
<p>짧게 Aggregate가 무엇이고, 어떻게 쓸 것인지 잘 정리되어 있다.</p>
<h1 id="precommit-hook"><a class="header" href="#precommit-hook">Precommit hook</a></h1>
<p>Precommit hook을 사용하면 커밋하기 전에 테스트를 실행해서, 테스트가
실패하면 커밋이 만들어지지 못하게 만들 수 있다. 실수로 이상한 커밋을
만들지 못하게 안전장치 역할을 한다.</p>
<h2 id="설치"><a class="header" href="#설치">설치</a></h2>
<p><a href="https://typicode.github.io/husky/#/?id=automatic-recommended">husky
가이드</a>
따라서 설치하자.</p>
<h2 id="pre-commit-훅-설정"><a class="header" href="#pre-commit-훅-설정">pre-commit 훅 설정</a></h2>
<p>설치가 완료되면 .husky 디렉토리에 pre-commit 파일이 있다. 이 파일에서
테스트 코드를 실행하면 된다. 우리는 Gradle로 프로젝트를 관리하기
때문에 gradle을 사용해서 테스트를 실행하자.</p>
<p>프로젝트 루트에 있는 gradlw에 test 인자를 주고 실행하자.</p>
<pre><code>../gradlew test
</code></pre>
<h1 id="git-subrepo"><a class="header" href="#git-subrepo">Git subrepo</a></h1>
<p><a href="https://github.com/ingydotnet/git-subrepo">https://github.com/ingydotnet/git-subrepo</a></p>
<p>git subrepo는 super repo에서 sub repo의 이력관리를 할 수 있게 해준다.</p>
<p><code>Common</code> 레포지토리를 <code>A</code>와 <code>B</code>레포가 공유한다고 가정하자. <code>A</code>는
자신만의 history로 <code>Common</code>을 수정한다. <code>B</code> 역시 자신만의 history로
<code>Common</code>을 수정한다. <code>A</code>와 <code>B</code>의 레포에서는 소스코드가 <code>Common</code>에
속하는지 안 속하는지 구분할 필요 없이 수정할 수 있다.</p>
<p><code>A</code>와 <code>B</code>가 <code>Common</code>을 수정한 뒤 수정한 내역을 <code>Common</code>의 레포에
반영해주어야 한다. <code>git subrepo push</code>를 이용해 반영할 수 있으며 <code>git subrepo pull</code>을 통해 <code>Common</code>의 변경사항을 가져올 수 있다.</p>
<p>subrepo의 장점은 <code>Common</code>의 변경 단위가 super repo에서 관리된다는
점이다.</p>
<h1 id="recursive-type-bound"><a class="header" href="#recursive-type-bound">Recursive type bound</a></h1>
<p><code>T extends SomeInterface&lt;T&gt;</code>에 대해 알아보자.</p>
<p>자바의 제네릭은 제네릭 타입에 대해서 조건을 걸 수 있다. 이를 <a href="https://docs.oracle.com/javase/tutorial/java/generics/bounded.html">Bounded
Type
Parameter</a>라고
부른다.</p>
<h2 id="가장-간단한-recursive-type-bound"><a class="header" href="#가장-간단한-recursive-type-bound">가장 간단한 Recursive Type Bound</a></h2>
<p>비교 가능한 제네릭 타입을 받고 싶을 때 <code>&lt;T extends Comparable&lt;T&gt;&gt;</code>를
사용한다.
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html"><code>Comparable&lt;X&gt;</code></a>를
구현한 타입은 <code>X</code>와 비교할 수 있다. 따라서 <code>&lt;T extends Comparable&lt;T&gt;&gt;</code>의 의미는 <code>T</code>는 <code>T</code>와 비교할 수 있다는 의미이다.</p>
<h2 id="빌더"><a class="header" href="#빌더">빌더</a></h2>
<p>부모 클래스의 빌더를 자식 클래스에서 재활용하기 위해서 Recursive Type
Bound를 사용한다. 예를 들어 <code>Builder&lt;T extends Builder&lt;T&gt;&gt;</code>와 같은
타입을 사용한다.</p>
<p>자바에서는 복잡한 객체를 생성하기 위해서 빌더를 사용한다. 빌더는
체이닝되는 setter 함수로 값을 쉽게 세팅할 수 있다. 메쏘드 체이닝을
위해서는 모든 setter 함수가 자기 자신의 타입을 리턴해야 한다.</p>
<p>부모 클래스의 빌더 클래스를 상속한 자식의 빌더클래스를 만들 때 어려운
점이 있다. 부모 클래스의 빌더에 정의된 setter는 부모의 빌더를 리턴하기
때문에 자식 빌더에서 유용하게 쓸 수 없다. 이 때 Recursive Type Bound를
쓰면 부모 클래스의 빌더에서 정의한 함수를 자식 클래스에서 사용할 수
있다.</p>
<p>아래 코드의 <code>returnSelf</code>는 자기 자신인 <code>Parent</code> 타입을 반환한다.
<code>Parent</code>를 상속한 <code>Child</code>의 <code>returnSelf</code>도 <code>Parent</code>를 반환한다.</p>
<pre><code class="language-java">class Parent {
  Parent returnSelf() {}
}

class Child extends Parent {
}

child.returnSelf() // 이 함수의 결과값은 Parent다.
</code></pre>
<p>아래 코드에서 <code>parent.returnSelf()</code>타입은 <code>Parent</code>이며
<code>child.returnSelf()</code>의 타입은 <code>Child</code>다. <code>returnSelf</code>를 <code>Child</code>에서
<code>override</code>하지 않아도 알아서 <code>Child</code>가 리턴된다.</p>
<pre><code class="language-java">class Parent&lt;Self extends Parent&lt;Self&gt;&gt; {
  @SuppressWarnings(&quot;unchecked&quot;)
  protected Self returnSelf() {
    return (Self)this;
  }
}

class Child extends Parent&lt;Child&gt; {
}
</code></pre>
<p><code>bitcoinj</code> 라이브러리의 <code>DetermisticKeyChain</code> 클래스의 빌더가 이
패턴을 사용한다. 부모 클래스인 <code>DeterministicKeyChain</code>의 빌더가
<a href="https://github.com/bitcoinj/bitcoinj/blob/68097e11f673ddaf16ec4e2f71f7e676d581f350/core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java#L167">여기</a>에
정의되어 있다. 자식 클래스인 <a href="https://github.com/bitcoinj/bitcoinj/blob/68097e11f673ddaf16ec4e2f71f7e676d581f350/core/src/main/java/org/bitcoinj/wallet/MarriedKeyChain.java#L66"><code>MarriedKeyChain</code>의
빌더</a>가
<code>DeterministicKeyChain</code>의 빌더를 상속한다.</p>
<h2 id="왜-헷갈리는가"><a class="header" href="#왜-헷갈리는가">왜 헷갈리는가</a></h2>
<p><code>&lt;T extends Comparable&lt;T&gt;&gt;</code>은 직관적이지 않다. 이 코드가 하고싶은 말은
&quot;<code>T</code>는 <code>T</code> 자기 자신과 비교할 수 있다&quot;이다. 이는 <code>&lt;T is Comparable&gt;</code>
이라고만 표현해도 충분하다. Java에서 인터페이스는 <code>Self</code> 타입을 쓸 수
없이 때문에 인터페이스에 직접 명시해야 한다.</p>
<p><code>class Builder&lt;T extends Builder&lt;T&gt;&gt;</code> 역시 마찬가지이다. 빌더 클래스는
자기자신을 리턴하는 메쏘드를 만들고 싶지만 <code>Self</code> 타입이 없다. <code>T extends Builder&lt;T&gt;</code> 파트를 단순히 <code>Self</code> 라고 이해하고, <code>T</code>가 나올
때마다 자기 자신을 의미한다고 이해하면 된다.</p>
<h2 id="다른-언어나-환경과의-비교"><a class="header" href="#다른-언어나-환경과의-비교">다른 언어나 환경과의 비교</a></h2>
<p>다른 언어들의 상황도 비슷하다. C++에서는 <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curly recurring template
pattern</a>이라고
부른다. C# 역시
<a href="https://blog.arkanosoft.com/index.php/crtp-c/">CRTP</a>라고 부른다.</p>
<p>Rust는 <code>Self</code> 타입을 트레잇에서 사용할 수 있다. 다음 코드는 Rust에서
비교를 정의하는
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>이다.
<code>Rhs</code>의 기본 값으로 <code>Self</code>를 사용한다. Rust는 상속의 개념도 없기
때문에 상황이 더 간단하다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialEq&lt;Rhs: ?Sized = Self&gt; {
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="참고"><a class="header" href="#참고">참고</a></h2>
<p><a href="https://medium.com/@hazraarka072/fluent-builder-and-powering-it-up-with-recursive-generics-in-java-483005a85fcd">https://medium.com/@hazraarka072/fluent-builder-and-powering-it-up-with-recursive-generics-in-java-483005a85fcd</a></p>
<h1 id="bounded-wildcards"><a class="header" href="#bounded-wildcards">Bounded Wildcards</a></h1>
<p><a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html">https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html</a>에서
Bounded Wildcards 항목 참조</p>
<p><code>Collection&lt;?&gt;</code>는 모든 <code>Collection&lt;T&gt;</code> 타입의 super 타입이다.</p>
<p><code>Collection&lt;T extends Shape&gt;</code>는 <code>Shape</code>를 상속한 모든 타입 <code>X</code>에
대해서, <code>Collection&lt;X&gt;</code>의 super 타입이다.</p>
<p>일반적으로 <code>Collection&lt;Child&gt;</code>는 <code>Collection&lt;Parent&gt;</code>의 자식 타입이
아니다. 따라서 Bounded Wildcard로 Collection의 상속 관계를 쉽게 표현할
수 있다.</p>
<h2 id="왜"><a class="header" href="#왜">왜</a></h2>
<p>왜 <code>Collection&lt;Child&gt;</code>를 <code>Collection&lt;Parent&gt;</code> 대신 쓸 수 없는 걸까. 그
이유는 변경 가능성 때문이다. 단적으로 <code>add</code>를 쓸 수 없다.
<code>Collection&lt;Child&gt;</code> 타입의 값을 <code>Collection&lt;Parent&gt;</code>타입으로 읽는
상황을 가정하자. <code>Collection&lt;Parent&gt;</code>에는 <code>OtherChild</code>타입의 값을
추가할 수 있지만 <code>Collection&lt;Child&gt;</code>에는 불가능하다. 따라서
<code>Collection&lt;Child&gt;</code>를 <code>Collection&lt;Parent&gt;</code> 대신 쓸 수 없다.</p>
<p>Wildcard를 사용하면 wildcard에 해당하는 타입을 만들 수 없기 때문에
안전하게 subtype과계를 만들 수 있다.</p>
<h1 id="raw-type"><a class="header" href="#raw-type">Raw Type</a></h1>
<p><a href="https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html">https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html</a></p>
<p>Java의 Generic 문법이 도입되기 전 모든 객체를 <code>Object</code> 클래스로
캐스팅하여 코드 중복을 제거했다. 이 레거시 코드를 지원하기 위해서
raw타입을 사용한다. Generic 클래스 혹은 인터페이스에서 <code>&lt;T&gt;</code> 파트를 뺀
타입을 raw 타입이라고 부른다. <code>&lt;T&gt;</code> 대신 <code>Object</code>타입을 사용한 코드를
쓸 수 있다.</p>
<p>일반적으로 레거시 코드가 아닌 이상 <code>&lt;T&gt;</code>를 쓸 필요가 없다.</p>
<h1 id="null"><a class="header" href="#null">Null</a></h1>
<p>Java는 모든 reference 타입이 null을 가질 수 있기 때문에 조심해야 한다.</p>
<h2 id="nonnull"><a class="header" href="#nonnull">@NonNull</a></h2>
<p>다양한 패키지에서 NonNull 어트리뷰트를 제공한다. 해치랩스에서는 어떤
방식을 쓰고 무엇이 어떤 효과를 가지는지 알아보자.</p>
<h3 id="intellij-nullable과-notnull"><a class="header" href="#intellij-nullable과-notnull">IntelliJ @Nullable과 @NotNull</a></h3>
<p><a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IntelliJ IDEA의 @Nullable과 @NotNull에 대한 블로그</a>를 참고하자.</p>
<p>이 어노테이션을 사용하면 IntelliJ IDEA가 NullPointerException이 나올
수 있는 경우에 경고를 한다.</p>
<h1 id="javadoc"><a class="header" href="#javadoc">Javadoc</a></h1>
<p>Javadoc은 자바로 작성한 프로그램을 문서화하는 표준 도구다.</p>
<h2 id="자바독-생성"><a class="header" href="#자바독-생성">자바독 생성</a></h2>
<p>인텔리제이에서 함수, 클래스, 필드 이름에 커서를 두고 alt-enter를
누르면 자바독을 생성하는 메뉴 버튼이 뜬다.</p>
<h2 id="다른-소스코드에-대한-링크"><a class="header" href="#다른-소스코드에-대한-링크">다른 소스코드에 대한 링크</a></h2>
<p>문서화할 때 다른 클래스, 변수, 필드에 링크를 걸 수 있다.</p>
<p>태그들에 대해 더 자세히 알고싶다면, <a href="https://idratherbewriting.com/java-javadoc-tags/">자주 사용하는 자바독 태그를
소개하는 블로그</a>를
참고하자.</p>
<h3 id="see"><a class="header" href="#see">@see</a></h3>
<p>다른 문서를 참고해야 할 때 @see 태그를 사용해서 다른 클래스나 필드등을
링크 걸 수 있다. 단순 링크에 비해서 참고사항이라는 컨텍스트를 더
전달할 수 있다.</p>
<h3 id="link"><a class="header" href="#link">@link</a></h3>
<p>{@link} 를 쓰면 링크를 만들어 준다. 바로 클래스 이름을 작성하기
시작하면, 인텔리제이가 클래스 이름을 자동완성 해준다. 필드나 메쏘드를 링크걸고 싶다면 <code>#</code>으로 시작하자.</p>
<h2 id="패키지에-대한-문서화"><a class="header" href="#패키지에-대한-문서화">패키지에 대한 문서화</a></h2>
<p>package-info.java 함수를 만든 뒤 해당 파일의 패키지 선언 위에서 작성한다.</p>
<p><a href="https://stackoverflow.com/a/624474">package-info.java에 대한 스택오버플로우 답변</a>을 참고했다.</p>
<h2 id="private-변수에-대한-문서화"><a class="header" href="#private-변수에-대한-문서화">private 변수에 대한 문서화</a></h2>
<p>private 변수에만 자바독을 작성하고 getter와 setter에는 자바독을
작성하지 않으면 해당 자바독은 코드를 직접 읽지 않는 이상 보이지
않는다. 자바독을 웹페이지로 렌더하거나, IDE에서 문서를 보여줄 때
보이지 않게 된다.</p>
<p>Klaytn의 Caver-java도 해당 문제를 가지고 있다. 관련된
<a href="https://github.com/klaytn/caver-java/issues/208">이슈</a>가 등록되어
있다.</p>
<p>lombok의 @Getter와 @Setter 어트리뷰트를 사용해서 getter와 setter를
생성한 경우 private 변수에 적은 자바독을 getter와 setter에 복사해준다.<sup class="footnote-reference"><a href="#javadoc-getter-setter-lombok">1</a></sup></p>
<div class="footnote-definition" id="javadoc-getter-setter-lombok"><sup class="footnote-definition-label">1</sup>
<pre><code>이
[링크](https://projectlombok.org/features/GetterSetter)를
참고하자. 완전히 복사는 아니고 좀 더 복잡한 설정이 가능하다.
</code></pre>
</div>
<h1 id="spring-di"><a class="header" href="#spring-di">Spring DI</a></h1>
<p>스프링 라이브러리의 핵심 기능 중 하나가 의존성 주입이다. 의존성
주입이란, 객체 A가 객체 B를 필요로 할 때, 객체 A에게 객체 B를 넣어주는
것이다. 반대로, 객체 A가 객체 B를 필요로 할 때 객체 A가 객체 B를
생성하는 것은 의존성 주입이 아니다.</p>
<p>의존성 주입을 하면 기능을 사용하는 코드의 변경 없이 기능을 제공하는
코드의 구현을 쉽게 바꿀 수 있다.</p>
<h2 id="우리는-언제-쓰는가"><a class="header" href="#우리는-언제-쓰는가">우리는 언제 쓰는가</a></h2>
<p>설정 값들과 싱글턴 객체들(Factory가 많다.)을 만들기 위해서 사용한다.
웹 서비스 레이어나, 도메인 레이어에서 필요한 객체들을 전달받는다.</p>
<p>예를 들어 비트코인 노드의 주소나, 이더리움 노드에 요청을 보낼 수 있는
클라이언트 등을 의존성 주입으로 처리한다. 덕분에 테스트 환경에서 해당
값을 쉽게 바꿀 수 있다.</p>
<h2 id="용어들"><a class="header" href="#용어들">용어들</a></h2>
<p>IoC Container는 의존성에 대한 정보를 담는 객체이다. 의존성들은 이름과
값을 가진다. IoC Container는 의존성의 이름으로 값을 찾거나 만들 수 있다.</p>
<p>Bean은 의존성으로 주입될 수 있는 겂을 말한다. Bean 다른 Bean을 의존할
수 있다.</p>
<h2 id="우리는-어떻게-쓰는가"><a class="header" href="#우리는-어떻게-쓰는가">우리는 어떻게 쓰는가</a></h2>
<p>Spring Boot를 사용하기 때문에 IoC Container를 직접 만들지 않는다.
Spring Boot를 사용하면 main 함수가 정의된 class 위에
<code>@SpringBootApplication</code>을 사용한다. @SpringBootApplication을 사용하면
자동으로 IoC Container를 만들고 package를 검색해서 bean 관련 설정을
찾아낸다.<sup class="footnote-reference"><a href="#spring-boot-application">1</a></sup></p>
<div class="footnote-definition" id="spring-boot-application"><sup class="footnote-definition-label">1</sup>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-using-springbootapplication-annotation">@SpringBootApplication 레퍼런스</a></p>
</div>
<p>Spring Boot의 웹 서비스 객체를 만들면 해당 객체는 필요한 Bean을
주입받을 수 있다. 웹 서비스 객체부터 시작해서 웹 서비스 객체가
의존하는 Bean, 그 Bean이 의존하는 Bean, ... 등이 연쇄적으로 자동생성
된다.</p>
<h2 id="dependency-설정"><a class="header" href="#dependency-설정">Dependency 설정</a></h2>
<p>Spring은 다양한 방법으로 Bean을 만들고 연결하는 방법을 표현할 수 있다.
XML을 사용하거나, Java annotation, 혹은 Java 코드를 사용해서 Bean의
연결 방법을 표시한다. 해치랩스에서는 Java annotation과 Java 코드를
통해 연결하는 방법을 사용한다.</p>
<h2 id="bean의-이름"><a class="header" href="#bean의-이름">Bean의 이름</a></h2>
<p>우리는 대부분의 경우 싱글턴 오브젝트에 대해서만 Bean을 만들기 때문에
이름을 정하지 않는다. 이름을 정하지 않으면 Spring이 적당히 이름을
만들지만 우리는 그 이름을 사용하지 않는다.</p>
<p>이름을 사용하지 않아도 타입을 기반으로 하는 Autowired 기능이 있기
때문에 문제 앖다.</p>
<p>설정값인 경우에는 BigInteger나 String 타입의 값으로 Bean을 만들기도 한다.
이 때는 <code>@Value</code> 어노테이션을 사용해서 이름을 명시한다.</p>
<h2 id="bean-등록하기"><a class="header" href="#bean-등록하기">Bean 등록하기</a></h2>
<h3 id="component"><a class="header" href="#component">@Component</a></h3>
<p>class 위에 <code>@Component</code>를 달면 해당 클래스는 다른 코드에서 주입받을 수
있는 Bean이 된다.</p>
<h3 id="service-controller-repository"><a class="header" href="#service-controller-repository">@Service, @Controller, @Repository</a></h3>
<p><code>@Component</code> 이외에도 <code>@Service</code>나 <code>@Controller</code>, <code>@Repository</code>와 같은
어노테이션을 클래스 위에 붙이면 클래스를 Bean으로 등록할 수 있다.</p>
<p>한 클래스에 <code>@Service</code>, <code>@Controller</code>, <code>@Repository</code>를 사용하면 그
클래스가 스프링 디펜던시 인젝션으로 사용되는 것 뿐만 아니라 더 많은
의미 혹은 기능을 가지게 된다. 상황에 맞는 어노테이션을 사용하자.</p>
<h3 id="configuration"><a class="header" href="#configuration">@Configuration</a></h3>
<p>우리가 직접 정의하지 않은 class를 주입하고 싶을 때 <code>@Configuration</code>을
사용한다. @Configuration을 사용하여 Bean을 정의하는 방법을 Java-based
Configuration<sup class="footnote-reference"><a href="#java-based-configuration">2</a></sup>이라고 부른다.</p>
<div class="footnote-definition" id="java-based-configuration"><sup class="footnote-definition-label">2</sup>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java</a></p>
</div>
<p>Configuration용 클래스 위에 @Configuration 어노테이션을 붙이고, bean을
제공할 메쏘드들 위에 @Bean을 붙인다. 그러면 @Bean이 붙은 메쏘드의 리턴
값이 bean에 등록된다.</p>
<h2 id="bean-주입받기"><a class="header" href="#bean-주입받기">Bean 주입받기</a></h2>
<h3 id="필드에-autowired를-달기"><a class="header" href="#필드에-autowired를-달기">필드에 @Autowired를 달기</a></h3>
<p>IoC Container에 의해서 생성되는 객체가 @Autowired 어노테이션을 가지고
있다면, 해당 변수는 IoC Container가 자동으로 넣어준다. 우리는 Bean의
이름을 붙이지 않으므로 타입을 기반으로 값이 세팅된다.</p>
<h3 id="생성자의-인자로-주입받기"><a class="header" href="#생성자의-인자로-주입받기">생성자의 인자로 주입받기</a></h3>
<p>별다른 어노테이션을 붙이지 않더라도, 생성자의 인자로 있는 값들을
주입받을 수 있다. 우리는 Bean에 이름을 붙이지 않으므로, 타입을
기반으로 값이 세팅된다.</p>
<p>생성자가 하나만 있으면 그 생성자가 불린다. 여러 생성자가 있으면 원하는
생성자에 @Autowired를 붙여 주어야 한다.<sup class="footnote-reference"><a href="#constructor-one-or-autowired">3</a></sup></p>
<div class="footnote-definition" id="constructor-one-or-autowired"><sup class="footnote-definition-label">3</sup>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-spring-beans-and-dependency-injection">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-spring-beans-and-dependency-injection</a></p>
</div>
<h3 id="value를-써서-설정파일로부터-빈을-주입받기"><a class="header" href="#value를-써서-설정파일로부터-빈을-주입받기">@Value를 써서 설정파일로부터 빈을 주입받기</a></h3>
<p>@Value를 쓰면 설정파일로부터 Bean을 주입받을 수 있다. Constructor의
인자 앞에 붙이거나, 클래스의 필드에 붙일 수 있다. 우리는
application-xxx.yml 파일로부터 설정값을 주입받는다.</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-value-annotations">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-value-annotations</a></p>
<h2 id="annotation을-썼을-때-실제로-일어나는-일"><a class="header" href="#annotation을-썼을-때-실제로-일어나는-일">Annotation을 썼을 때 실제로 일어나는 일</a></h2>
<p>TBD</p>
<h2 id="spring-boot-없이-쓴다면"><a class="header" href="#spring-boot-없이-쓴다면">Spring Boot 없이 쓴다면</a></h2>
<p>TBD</p>
<h2 id="intellij-꿀팁"><a class="header" href="#intellij-꿀팁">IntelliJ 꿀팁</a></h2>
<p>의존성을 받을 수 있는 경우 의존성이 적힌 코드 왼쪽에 특별한 아이콘을
표시해준다. 실수로 의존성을 찾을 수 없는 경우에 쉽게 디버깅할 수 있다.</p>
<h2 id="레퍼런스"><a class="header" href="#레퍼런스">레퍼런스</a></h2>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html</a></p>
<h1 id="jpa-transaction-안에서-io-call"><a class="header" href="#jpa-transaction-안에서-io-call">JPA Transaction 안에서 IO call</a></h1>
<h1 id="안씀spring-boot-actuator"><a class="header" href="#안씀spring-boot-actuator">(안씀)Spring boot actuator</a></h1>
<p>프로덕션에서 웹서버를 모니터링하기 위한 도구다. spring boot 웹서버의
기본 로거가 리퀘스트 리스판스를 로그로 남겨주지 않아서 사용하려다
실패했다. http trace를 남기는 endpoint가 있지만 디버깅 용으로 쓰기엔
불편하다.</p>
<h1 id="spring-boot-web-filter를-사용해서-request-log-남기기"><a class="header" href="#spring-boot-web-filter를-사용해서-request-log-남기기">Spring Boot Web Filter를 사용해서 request log 남기기</a></h1>
<p><a href="https://stackoverflow.com/questions/33744875/spring-boot-how-to-log-all-requests-and-responses-with-exceptions-in-single-pl/43155103#43155103">스택오버플로우
답변</a>에서
리퀘스트 로그를 남기는 방법을 찾았다.</p>
<h2 id="web-filters"><a class="header" href="#web-filters">Web Filters</a></h2>
<p><a href="https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/spring-boot-features.html#boot-features-webflux-web-filters">Spring Boot Features
페이지</a>에
Web Filters에 대한 내용이 짧게 적혀 있다.</p>
<p>Spring Boot WebFlux<sup class="footnote-reference"><a href="#webflux">1</a></sup>를 사용할 때 Web Filter를 사용하면
핸들러가 request를 처리하기 전 request를 수정할 수 있다. 핸들러가
request를 처리한 후 response를 수정할 수 있다. request나 response의
로그를 남기는 것도 Web Filter를 사용할 수 있다.</p>
<p>Web Filter를 Bean으로 Spring DI에 등록하면 Spring Boot Application이
자동으로 불러와서 사용한다. Spring DI에 대한 내용은 이 사이트의
<a href="./spring-di.html">Spring DI</a> 글에 정리되어 있다.</p>
<p><em>spring-web.jar</em>에 제공되는 filter들이 있다. 이들을 잘 설명한 공식
문서는 찾지 못했고, <a href="https://www.javadoc.io/doc/org.springframework/spring-web/latest/org/springframework/web/filter/package-summary.html">spring-web의
JavaDoc페이지</a>에서
간단한 설명을 찾을 수 있다.</p>
<p><sup class="footnote-reference"><a href="#webflux">1</a></sup>WebFlux가 무엇인지 모르겠지만, spring boot tutorial을 따라했다면
WebFlux를 쓰고 있을 것이다. Spring Boot Web application이 제공하는
인터페이스가 여럿 있고, 가장 최신 방법이 WebFlux인 것으로 보인다.</p>
<h1 id="tbd-spring-data-jpa-transaction중-io"><a class="header" href="#tbd-spring-data-jpa-transaction중-io">(TBD) Spring Data JPA Transaction중 IO</a></h1>
<p>Spring Data JPA를 쓸 때 서비스 단위에서 Transaction을 건다. Service
안에서 비트코인, 이더리움, 클레이튼 노드에 요청을 할 때가 꼭 생긴다.
이 때 트랜잭션 안에서 IO를 하는 건 디비 성능에 문제를 일으킬 수 있다.</p>
<h2 id="베스트-프랙티스를-찾아보자"><a class="header" href="#베스트-프랙티스를-찾아보자">베스트 프랙티스를 찾아보자</a></h2>
<p>Spring Data JPA와 IO call, blocking call, web request등을 같이 검색해
봤지만 이에 대한 유의미한 검색 결과를 찾지 못했다.</p>
<h1 id="junit"><a class="header" href="#junit">JUnit</a></h1>
<h2 id="주의할-점"><a class="header" href="#주의할-점">주의할 점</a></h2>
<p>JUnit의 테스트 함수는 private이면 테스트가 동작하지 않는다.</p>
<p>TBD</p>
<h1 id="jackson"><a class="header" href="#jackson">Jackson</a></h1>
<p>자바에서 자주 사용하는 serialization 라이브러리.
<a href="https://github.com/FasterXML/jackson">깃헙 링크</a></p>
<h2 id="field-하나인-pojo가-requestbody에-있을-때-에러"><a class="header" href="#field-하나인-pojo가-requestbody에-있을-때-에러">Field 하나인 POJO가 @RequestBody에 있을 때 에러</a></h2>
<p>Spring Boot Web Application을 만들 때의 이야기다. JSON 바디를 받는
Post 요청을 처리할 때 예상치 못한 에러를 만났다. Spring Boot에서는
<code>@RequestBody</code> 어노테이션을 달아서 Body를 Deserialize한 객체를 받을 수
있다.</p>
<p>다음과 같이 인자 하나를 받는 API였는데, request body용 객체를
Deserialize할 때 에러가 발생했다. 해당 객체에 사용하지 않는 필드를
추가하면 잘 동작한다.</p>
<pre><code>{
  &quot;passphrase&quot;: &quot;xx&quot;
}
</code></pre>
<h3 id="추측"><a class="header" href="#추측">추측</a></h3>
<p>field가 하나인 class를 Deserialize할 때 특별한 처리가 있는 것 같다. 이
동작이 설명된 곳, 혹은 코드를 찾자.</p>
<h1 id="caver"><a class="header" href="#caver">Caver</a></h1>
<h2 id="caver-java-이해하기"><a class="header" href="#caver-java-이해하기">Caver-java 이해하기</a></h2>
<p>Caver-java는 Klaytn 노드가 제공하는 JSON-RPC를 자바 코드로 호출할 수
있게 해준다. 안전하고 정리가 잘 된 자바 객체를 만들어주지 않기 때문에
조심해야 한다. JSON-RPC에서 응답으로 주는 JSON 값을 기계적으로 Java
Class로 매핑한 것에 가깝다. 라이브러리의 문서화보다 JSON-RPC 스펙을
참고하는 것이 더 안전하다.</p>
<p>이 <a href="https://docs.klaytn.com/bapp/json-rpc/api-references">링크</a>에서 클레이튼의 JSON RPC 스펙을 읽을 수 있다.</p>
<h2 id="caver-java-javadoc"><a class="header" href="#caver-java-javadoc">Caver-java Javadoc</a></h2>
<p>Caver-java는 Javadoc 문서화가 잘 안되어 있다. 간혹 getter, setter에는
문서화가 안되어 있더라도, private 필드에는 되어 있는 경우가 있다.
필드에 대한 설명이 궁금하면 함수의 정의로 간 뒤 소스코드를 읽어보자.</p>
<h2 id="block에-담겨있는-트랜잭션-타입"><a class="header" href="#block에-담겨있는-트랜잭션-타입">block에 담겨있는 트랜잭션 타입</a></h2>
<p><code>Transaction.TransactionData</code> 이다. 문서에는 트랜잭션 타입이라는 말만
있고. 정확한 클래스 이름을 알려주지 않는다.</p>
<h2 id="valuetransfertransaction의-value-조심"><a class="header" href="#valuetransfertransaction의-value-조심">ValueTransferTransaction의 value 조심</a></h2>
<p>문자열로 넣으면 해당 문자열이 hexa decimal format으로 인식한다.
BigInteger 타입으로 넣으면 원하는 겂이 잘 들어간다.</p>
<h1 id="bitcoinj-hd-wallet"><a class="header" href="#bitcoinj-hd-wallet">bitcoinj HD wallet</a></h1>
<p>bitcoinj 라이브러리는 HD wallet 기능을 제공한다. 이를 이더리움이나
클레이튼에서도 쓸 수 있다.</p>
<p>다만 HD wallet기능이 bitcoinj의 지갑 기능에 강하게 연결되어 있어서
제공되는 인터페이스가 친절하지 않다. 적절히 지갑의 기능을 다른
목적으로 감싸서 사용하자.</p>
<h2 id="클래스들"><a class="header" href="#클래스들">클래스들</a></h2>
<p>DeterministicSeed</p>
<p>DeterministicKeyChain</p>
<p>// externalParentKey, internalParentKey
//issuedExternalKeys, issuedInternalKeys</p>
<p>isFollowing
watching</p>
<p>org/bitcoinj/wallet/DeterministicKeyChain.java</p>
<p>DeterministicHierarchy</p>
<p>DeterministicKey</p>
<h1 id="hd-wallet"><a class="header" href="#hd-wallet">HD wallet</a></h1>
<p><a href="https://developer.bitcoin.org/devguide/wallets.html#hierarchical-deterministic-key-creation">bitcoin dev guide의 hd wallet에 대한
글</a></p>
<p>하나의 키로 여러 키를 쉽게 관리하는 방식이다. 하나의 비밀 정보로부터
수 많은 키를 생성할 수 있다. 간단한 하나의 비밀정보만 보관하는 것으로
모든 지갑을 쉽게 관리할 수 있다.</p>
<h2 id="비트코인에서-hd-wallet이-의미-있는-이유"><a class="header" href="#비트코인에서-hd-wallet이-의미-있는-이유">비트코인에서 HD wallet이 의미 있는 이유</a></h2>
<p>비트코인은 privacy를 신경을 많이 쓴다. 하나의 주소를 계속 사용하면
주소로 오가는 비트코인을 추적할 수 있게 된다. 따라서 여러 계정을
사용하거나 계정을 자주 바꾸는 것이 권장된다.</p>
<p>계정을 많이 생성하면 그만큼 많은 비밀키를 생성해야 해서 관리가
복잡해진다. HD wallet을 사용하면 적은 양의 비밀정보 만으로 수많은
계정을 쉽게 백업할 수 있다.</p>
<h2 id="동작-방식"><a class="header" href="#동작-방식">동작 방식</a></h2>
<p>비밀키는 간단한 숫자다. 여기에 1, 2, 3 등을 더해서 새로운 비밀키를
만들 수 있다. 단순히 1, 2, 3을 더하는 건 쉽게 부모 키를 역추적할 수 있기 때문에
해시와 추가적인 정보를 넣어서 더 복잡하게 만든다.</p>
<p>HD Wallet는 비밀키 혹은 공개키와 Chain Code라는 값을 함께 관리한다.
부모 키와 부모의 Chain Code로부터 자식 키와 자식의 Chain Code를 만들어
낸다. 아래 수도코드 방식처럼 자식의 키와 자식의 Chain Code를 만든다.</p>
<pre><code>(left_random, right_random) = Hash(parent_chain_code, parent_public_key, i)
child_private_key = parent_private_key + left_random
child_chain_code = right_random
</code></pre>
<h2 id="extended-key"><a class="header" href="#extended-key">Extended key</a></h2>
<p>키와 Chain Code를 함께 묶어서 Extended Key라고 부른다. Public Key와
Chain Code를 합치면 Extended Public Key라고 부른다. Private Key와
Chain Code를 합치면 Extended Private Key라고 부른다.</p>
<h2 id="root-seed와-master"><a class="header" href="#root-seed와-master">Root Seed와 Master</a></h2>
<p>Root Seed는 첫 번째 Private Key와 Chain Code를 만들기 위해 필요한
정보다. Root Seed를 한 번 해시하여 만들어낸 정보를 절반으로 잘라서
하나를 Private Key, 다른 하나를 Chain Code로 사용한다.</p>
<p>가장 먼저 만들어지고 모든 키의 부모가 되는 키를 Master 키라고 부른다.
비밀키와 공개키는 각각 Master Private Key와 Master Public Key라고
부른다.</p>
<h2 id="hardened-key"><a class="header" href="#hardened-key">Hardened Key</a></h2>
<p>부모의 Chain Code와 자식의 비밀 키가 노출되었을 때 부모의 private
키까지 노출되는 문제를 막는 방법이다.</p>
<p>키들 derive하는 방법을 둘로 나누어 하나는 normal 방식, 하나는 hardened
방식이라고 부른다. normal 방식은 derive할 때 부모의 공개키와 Chain
Code만 필요하다. hardened 방식은 derive할 때 부모의 <em>비밀키</em>와
ChainCode가 필요하다.</p>
<p>부모의 비밀키가 필요하게 만듬으로써 부모의 ChainCode와 자식의 비밀
키로 부모의 비밀키를 알아내는 게 불가능해 진다.</p>
<h2 id="key-tree-노테이션"><a class="header" href="#key-tree-노테이션">key tree 노테이션</a></h2>
<ul>
<li>Master Private Key는 <code>m</code>으로 지칭한다.</li>
<li>Master Public Key는 <code>M</code>으로 지칭한다.</li>
<li>Master Key의 <code>i</code>번째 normal derived private key는 <code>m/i</code></li>
<li>Master key의 <code>i</code>번째 hardened derived private key는 <code>m/i_H</code> 혹은 <code>m/i'</code></li>
<li><code>m/44'/0'/0'/0/1</code>은 마스터의 44번째 hardened, 0번째 hardened, 0번째
hardened, 0번째 normal, 1번째 normal derive된 비밀키다.</li>
<li><code>M/44'/0'/0'/0/1</code>은 마스터의 44번째 hardened, 0번째 hardened, 0번째
hardened, 0번째 normal, 1번째 normal derive된 공개키다.</li>
</ul>
<h2 id="네모닉-코드로부터-root-seed-생성하기"><a class="header" href="#네모닉-코드로부터-root-seed-생성하기">네모닉 코드로부터 Root Seed 생성하기</a></h2>
<p>랜덤으로 생성한 단어들로부터 seed를 생성할 수 있다. 자세한 규칙은
BIP39에 명시되어 있다.</p>
<h1 id="secp256k1"><a class="header" href="#secp256k1">secp256k1</a></h1>
<p>secp256k1은 ECDSA라는 서명 알고리즘에서 사용하는 커브 중 하나다. ECDSA
서명 알고리즘은 몇 가지 타원 곡선을 선택해서 사용한다. BitCoin,
Ethereum, Klaytn 모두 계정의 키로 ECDSA를 사용하며, secp256k1 커브를 사용한다.</p>
<h2 id="퍼블릭-키의-포맷"><a class="header" href="#퍼블릭-키의-포맷">퍼블릭 키의 포맷</a></h2>
<p>ECDSA 알고리즘에서 비밀키는 하나의 실수로 표현된다. 공개키는
G(generation point)라는 특별한 점에 비밀키를 곱한 값으로 표현된다.</p>
<p>비밀키는 하나의 숫자이므로 매우 간단하게 숫자로 표현하고, 바이너리
데이터로 저장할 수 있다. 공개키는 2차원 좌표계의 점이기 때문에 표현할
수 있는 방법이 여러가지다. x좌표와, y좌표를 이어붙여서 사용하거나,
x좌표와 (y 좌표의 부호)만 저장할 때도 있다.</p>
<p>체인에 따라서 서로 다른 포맷의 공개키를 사용할 수 있으므로 주의해야
한다.</p>
<h1 id="tbd-klaytn-fee-계산"><a class="header" href="#tbd-klaytn-fee-계산">(TBD) klaytn fee 계산</a></h1>
<p>클레이튼은 fee payer를 따로 지정할 수 있다. fee payer와 트랜잭션
sender 사이에 피를 나눠서 낼 수 있다.</p>
<h1 id="ecdsa-공개키-인코딩"><a class="header" href="#ecdsa-공개키-인코딩">ECDSA 공개키 인코딩</a></h1>
<p>ECDSA 알고리즘에서 공개키는 이차원에서 표현되는 타원곡선 위의 한
점이다. 따라서 X좌표와 Y좌표를 가진다. 비트코인과 클레이튼은 SEC
인코딩을 따르며, 이더리움은 살짝 다른 자체 인코딩 방식을 사용한다.</p>
<h2 id="비트코인과-sec-인코딩"><a class="header" href="#비트코인과-sec-인코딩">비트코인과 SEC 인코딩</a></h2>
<p>Standards of Efficient Cryptography (SEC)는 Elliptic Curve에서
공개키의 인코딩 방식을 정의한다.<sup class="footnote-reference"><a href="#sec-public-encoding">1</a></sup> 비트코인은
SEC의 방법을 따라서 공개키를 인코딩한다.</p>
<div class="footnote-definition" id="sec-public-encoding"><sup class="footnote-definition-label">1</sup>
<p><a href="http://www.secg.org/sec1-v2.pdf">http://www.secg.org/sec1-v2.pdf</a></p>
</div>
<p>SEC 인코딩은 압축의 유무에 따라 두가지 방식으로 공개키를 인코딩한다.
하나는 압축하는 것이고 다른 하나는 압축하지 않는 방법이다.</p>
<ul>
<li>압축하지 않는 경우 맨 처음에 16진수 04를 붙이고 그 뒤에 X 좌표, 그
뒤에 Y 좌표를 붙인다.</li>
<li>압축하는 경우 y 값이 짝수면 16진수 02를, 홀수면 16진수 03을 앞에
붙이고 뒤에 X 좌표를 붙인다.<sup class="footnote-reference"><a href="#programming-bitcoin-serialization">2</a></sup></li>
</ul>
<div class="footnote-definition" id="programming-bitcoin-serialization"><sup class="footnote-definition-label">2</sup>
<p><a href="https://learning.oreilly.com/library/view/programming-bitcoin/9781492031482/ch04.html">책 Programming Bitcoin의
Serialization
챕터</a>참조.
SEC 인코딩 문서를 보면 인코딩 방법이 수학적으로 정리되어 있지만
이해하기 힘들다. Programming Bitcoin 책에 수학적인 배경지식이
부족해도 이해할 수 있게 설명되어 있다.</p>
</div>
<h3 id="bitcoinj"><a class="header" href="#bitcoinj">BitcoinJ</a></h3>
<p>BitcoinJ는 Address를 만들 때 SEC로 인코딩 되어 있는 공개키 값을
받는다. <code>Address</code>를 만들 때 <code>ECKey</code>타입을 받는다. <code>byte[]</code> 로부터
<code>ECKey</code>를 만들 때, <code>ECKey.isPubKeyCompressed</code>를 호출하여 첫 번째
<code>byte</code>를 검사한다.<sup class="footnote-reference"><a href="#bitcoinj-fromKey">3</a></sup></p>
<div class="footnote-definition" id="bitcoinj-fromKey"><sup class="footnote-definition-label">3</sup>
<p><a href="https://github.com/bitcoinj/bitcoinj/blob/388ca037ef5e6211d5f8ba4ec5b58f4514c7b4fa/core/src/main/java/org/bitcoinj/core/Address.java#L82">https://github.com/bitcoinj/bitcoinj/blob/388ca037ef5e6211d5f8ba4ec5b58f4514c7b4fa/core/src/main/java/org/bitcoinj/core/Address.java#L82</a></p>
</div>
<h2 id="ethereum의-공개키-인코딩"><a class="header" href="#ethereum의-공개키-인코딩">Ethereum의 공개키 인코딩</a></h2>
<p>이더리움은 자체 방식을 써서 공개키를 인코딩한다. 공식적인 레퍼런스를
찾진 못했다. <a href="http://gavwood.com/paper.pdf">Ethereum의 YellowPaper</a>를
보면 매우 짧게 공개키는 두 숫자를 이어붙인 64바이트 어레이라고
적혀 있다.<sup class="footnote-reference"><a href="#public-key-in-yellow-paper">4</a></sup></p>
<div class="footnote-definition" id="public-key-in-yellow-paper"><sup class="footnote-definition-label">4</sup>
<p>Where <code>p_u</code> is the public key, assumed
to be a byte array of size 64 (formed from the concatenation of
two positiveintegers each&lt;<code>2^256</code>)</p>
</div>
<p>Ethereum 관련 라이브러리들에는 각각 이에 대한 설명이 적혀있다.</p>
<p>아래는 Web3J에 달린 주석이다. <a href="https://github.com/web3j/web3j/blob/116539fff875a083c896b2d569d17416dfeb8a6f/crypto/src/main/java/org/web3j/crypto/ECKeyPair.java#L68-L70">GitHub link</a></p>
<pre><code>// Ethereum does not use encoded public keys like bitcoin - see
// https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm for details
// Additionally, as the first bit is a constant prefix (0x04) we ignore this value
</code></pre>
<p>아래는 <code>eth-keys</code> 라이브러리의
<a href="https://github.com/ethereum/eth-keys#keyapipublickeypublic_key_bytes">README.md</a>에
적힌 내용이다.</p>
<blockquote>
<p>Note that there are two other common formats for public keys: 65
bytes with a leading \x04 byte and 33 bytes starting with either
\x02 or \x03. To use the former with the PublicKey object, remove
the first byte. For the latter, refer to
PublicKey.from_compressed_bytes.</p>
</blockquote>
<h3 id="web3j"><a class="header" href="#web3j">Web3J</a></h3>
<p>Web3J의 코드는 <code>byte[]</code>로 들어온 public key가 유효한 Ethereum Public
Key 인코딩이라고 가정하고 유효성 검사를 하지 않는다.<sup class="footnote-reference"><a href="#web3j-getAddress">5</a></sup></p>
<div class="footnote-definition" id="web3j-getAddress"><sup class="footnote-definition-label">5</sup>
<p><a href="https://github.com/web3j/web3j/blob/116539fff875a083c896b2d569d17416dfeb8a6f/crypto/src/main/java/org/web3j/crypto/Keys.java#L113">https://github.com/web3j/web3j/blob/116539fff875a083c896b2d569d17416dfeb8a6f/crypto/src/main/java/org/web3j/crypto/Keys.java#L113</a></p>
</div>
<h2 id="klaytn과-공개키-인코딩"><a class="header" href="#klaytn과-공개키-인코딩">KLAYTN과 공개키 인코딩</a></h2>
<p>KLAYTN의 공식적인 공개키 인코딩 관련 문서를 찾지 못했다. caver의
소스코드를 봤을 때 SEC의 인코딩을 사용한다.</p>
<p>아래는 caver-java의 <code>AccountKeyPublic</code>에서 복사한 주석이다.</p>
<pre><code>/**
 * ECC Public Key value with &quot;SECP-256k1&quot; curve.
 * This String has following format.
 * 1. Uncompressed format : 0x{Public Key X point}||{Public Y point}
 * 2. Compressed format : 0x{02 or 03 || Public Key X}
 */
</code></pre>
<p>PrivateKey#getPublicKey 함수도 compressed를 인자로 받은 뒤 적절하게
0x02~0x04의 prefix를 붙여준다.<sup class="footnote-reference"><a href="#caver-java-privatekey-getpublickey">6</a></sup></p>
<pre><code class="language-java">public String getPublicKey(boolean compressed) {
    BigInteger publicKey = Sign.publicKeyFromPrivate(Numeric.toBigInt(privateKey));

    if(compressed) {
        return Utils.compressPublicKey(Numeric.toHexStringWithPrefixZeroPadded(publicKey, LEN_UNCOMPRESSED_PUBLIC_KEY_STRING));
    }

    return Numeric.toHexStringNoPrefixZeroPadded(publicKey, LEN_UNCOMPRESSED_PUBLIC_KEY_STRING);
}
</code></pre>
<div class="footnote-definition" id="caver-java-privatekey-getpublickey"><sup class="footnote-definition-label">6</sup>
<p><a href="https://github.com/klaytn/caver-java/blob/b5b1d39dc1a1c7b1b1a83fc581c9de842bdf57e4/core/src/main/java/com/klaytn/caver/wallet/keyring/PrivateKey.java#L116">getPublicKey 소스코드</a></p>
</div>
<h3 id="클레이튼의-getderivedaddress"><a class="header" href="#클레이튼의-getderivedaddress">클레이튼의 getDerivedAddress</a></h3>
<p>Caver의 <code>PrivateKey</code> <code>class</code>에는 <code>getDerivedAddress</code>라는 함수가 있다.
이 함수는 Address를 만들기 위해서 Ethereum 방식의 공개키 인코딩을
사용한 뒤 이더리움의 포맷의 주소를 사용해서 리턴한다. 내부 코드를 보면
Web3j의 <code>Keys.getAddress</code> 함수를 사용한다.</p>
<p>이더리움 방식의 공개키 인코딩이 외부에 노출된 건 아니지만 라이브러리
소스코드를 읽을 때 헷갈릴 수 있으니 주의하자.</p>
<p><a href="https://github.com/klaytn/caver-java/blob/b5b1d39dc1a1c7b1b1a83fc581c9de842bdf57e4/core/src/main/java/com/klaytn/caver/wallet/keyring/PrivateKey.java#L130">getDerivedAddress GitHub
링크</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

<script src="https://utteranc.es/client.js"
        repo="majecty/borre-haechi-dev-note"
        issue-term="pathname"
        label="comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        
	

    </body>
</html>
